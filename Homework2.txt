task#1
if n == 1 THEN return
FOR(i = 1; i <= n; i++) {
    FOR(j = 1; j <= n; j++) {
        // 
    }
}
В случае если n=1 это наилучший случай, алгоритму нужно сделать один шаг, наверное, это О(1)
В остальных случаях мы дважды идем по циклу и оба раза его длина n. Это O(n^2) 


task#2
FOR(i = n/2; i<=n;i++){
	FOR (j = 2; j <= n; j*2) {
		//
	} 
}
Первый цикл проходит длину сопоставимую n,а второй log2(n), так как начинается с двойки и увеличивается каждый раз в два раза.
Это O(nlog(n))


task#3
FOR(i = 0; i<n;i++){
	FOR (j = n; j > i; j--) {
		//
	}
}
Первый цикл проходит длину n,а второй n/2, так как он перестанет выполняться, как только значение j будет равно i 
(j уменьшается, а i растет одновременно и пропорционально)
Выходит O(n^2) 


task#4
numbers a=0, i=n; 
	WHILE i>0 {
	a=a+i
	i=i/2
	} 
}
Если n=0 или отрицательное число, то в цикл мы даже не зайдем, наверное, это О(1).
В других случаях, и если i по условию не целое число, то деление на два при условии, что i>0, 
возможно бесконечное количество времени, так как ноль не достижим.
А у бесконечности наверное нет временной сложности. И такой алгоритм неэффективен.





 


